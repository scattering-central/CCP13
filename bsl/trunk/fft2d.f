C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      SUBROUTINE FFT2D (A,B,NSIZ,ISGN,ITYPE,BUF,IDR)
C
C PURPOSE: PERFORM A TWO-DIMENSIONAL TRANSFORM FASTER THAN C06ADF ETC.
C
C AUTHOR: N.R.ARNOT Q.E.C
C         MODIFIED & TIDIED G.R.MANT  DARESBURY LABORATORY.
C
C LIMITATIONS:
C     (1) ARRAYS A,B MUST BE SQUARE
C     (2) DIMENSION N MUST BE COMPLETELY FACTORISABLE INTO 2,3,
C         AND 5. VIOLATION OF THIS CAUSES STOP WITH ERROR MESSAGE.
C         FACTORS OF 5 NOT YET IMPLEMENTED
C     (3) N MUST HAVE LESS THAN 9 FACTORS OF 2, 3, 4, OR 5 ONLY,
C         AND AT LEAST ONE OF THEM MUST BE 4
C
      REAL    A(1),B(1),BUF(1)
      INTEGER NSIZ,ISGN,ITYPE,IDR(1)
C
C A      : REAL PART 
C B      : IMAGINARY PART
C BUF    : HOLDS SINES DURING THE TRANSFORM, AND IS A BUFFER DURING THE
C          UNSCRAMBLE. IT MUST BE OF SIZE AT LEAST (9*NSIZ)/4 +1
C NSIZ   : IS A SINGLE DIMENSION A(N,N)
C ISGN   : +VE FOR FORWARD TRANSFORM, NEGATIVE FOR REVERSE
C          (NORMALISATION CONSTANT IS 1/N**2 ON REVESE TRANSFORM)
C ITYPE  : +VE IF TRANSFORM DEFINED AS SUM FROM 0 TO (N-1)
C          -VE IF TRANSFORM DEFINED AS SUM FROM (-N/2) TO (N/2 +1)
C IDR    : HOLDS ASSORTED CONSTANTS DURING TRANSFORM AND DIGIT-
C          REVERSED SUBSCRIPTS DURING UNSCRAMBLE. IT MUST BE AT LEAST
C          N ELEMENTS LONG.
C-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
C IMPLEMENTATION NOTE:
C  IF USERNM IS .TRUE. (DEFAULT .FALSE.) THE DEFAULT NORMALISATION DOES
C  NOT TAKE PLACE; INSTEAD, THE TRANSFORM IS CALCULATED AS A STRAIGHT
C  SUM & MULTIPLIED BY FORWRD (ISGN=+1) OR BAKWRD(ISGN=-1); DEFAULTS
C  OF THESE REAL VARIABLES ARE 1.0
C
C-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
C LOCAL VARIABLES:
C
      REAL    FORWRD,BAKWRD
      INTEGER NFACS(9),IX(9),IR(5),IDRINC(9)
      LOGICAL CENTRZ,RDXFOU,NOTWID,REVTRN,USERNM
C
      DATA USERNM/.FALSE./,FORWRD/1.0/,BAKWRD/1.0/
C
C-----------------------------------------------------------------------
      PI=ACOS (-1.0)
      IF (NSIZ.GE.0) THEN
         N = NSIZ
         NNR = NSIZ
C========NNR NOT N IF N A POWER OF 2 BEST ON CDC MACHINES BUT WASTES CORE
      ELSE
         N = -NSIZ
         NNR = N + 1
      ENDIF
      CENTRZ = ITYPE.LT.0
      REVTRN = ISGN.LT.0
      SIN120 = SIN(PI/1.5)
      SIN72 = SIN(PI/2.5)
      COS72 = COS(PI/2.5)
      C2  = COS72**2 - SIN72**2
      S2 = 2.0*COS72*SIN72
C========FACTORISE N
      II = 3
      NFAC=0
      ITEMP=N
      IF (((N/4)*4).EQ.N) GOTO 4
      II = 1
      GOTO 13
   4  CONTINUE
      DO 10 I=2,5
        J=7-I
   5    JTEMP=ITEMP/J
        IF(JTEMP*J .NE. ITEMP) GOTO 10
        NFAC=NFAC+1
        IF (NFAC.LT.9) GOTO 6
        II = 2
        GOTO 13
  6     NFACS(NFAC) = J
        ITEMP = JTEMP
        GOTO 5
  10  CONTINUE
      IF (ITEMP.EQ.1) GOTO 20
C
C********************************************************************
C
  13  WRITE(6,14) II,N
  14  FORMAT(' FOURIER FATAL FACTORISATION FAILURE NO. ',I4,
     & 2X,7HWITH N=  ,I4 )
C   REASONS ARE 1 -> NO FACTOR OF 4,  2 -> N TOO LARGE, AND
C             3 -> N HAS A PRIME FACTOR GREATER THAN 5
      STOP
C
C********************************************************************
C
  20  CONTINUE
C
C  SET UP TWIDDLE FACTOR LOOKUP TABLE. TO AVOID THE NEED FOR MODULO
C  INTEGER ARITHMETIC OR CONDITIONAL CODE IT IS LARGER THAN NECESSARY
C  2.25 CYCLES OF A SIN CURVE SAMPLED AT TWOPI/N ARE USED, ONE OR
C  EVEN 0.5 COULD BE USED ON A SMALL COMPUTER.
C
      TPBN = 6.283185307/FLOAT(N)
      J = N/2
      DO 35 I=1,J
        BUF(I) = SIN(FLOAT(I-1)*TPBN)
  35  CONTINUE
      II = J
      J = J+1
      K = (9*N)/4 +1
      DO 36 I=J,K
        BUF(I) = -BUF(I-II)
  36  CONTINUE
C
C  FASTER BUT LESS ACCURATE COULD USE TRIG IDENTITIES FOR
C  SIN((N+1)X) AND COS((N+1)X)
C
C  CONJUGATE IF REVERSE TRANSFORM
      IF(.NOT.REVTRN) GOTO 75
      J = N*N
      DO 73 I=1,J
        B(I) = -B(I)
  73  CONTINUE
  75  CONTINUE
C  NOW START ACTUAL TRANSFORM. AN INTERNAL PROCEDURE IS USED TO DO A SET
C  OF NTRANS TRANSFORMS OF IFAC POINTAS, THE COORSD OF THE FIRST OF
C  WHICH ARE PASSED IN IX(). UNLESS NOTWID IS TRUE, THE REFERENCING
C  OPERATION IS ALSO DONE.
C     IRETRN (ASSIGNED) IS LABEL TO RETURN TO AFTER TRANSFORMS DONE,
C  ITRTYP IS LABEL OF CODE FOR CORRECT (2, 3, 4, OR 5 POINT) TRANSFORM.
C
      ITWINC = 1
      ISKIP = N
      ISPAN = N
      DO 300 NF = 1,NFAC
        IFAC = NFACS(NF)
        RDXFOU = IFAC.EQ.4
        NP1 = N/4
        ISPAN = ISPAN/IFAC
        ICSEP=ISPAN
        IRSEP = ICSEP*NNR
        IF1 = IFAC-1
C  USE IDR IN THIS LOOP TO HOLD THE TWIDDLE FACTOR INCREMENTS
C
C  PRESET THE FOLLOWING INFO IN IDR AS GROUPS OF IFAC LOCATIONS :-
C       1       -> COLUMN NO. OF FIRST POINT OF ELEMENTAL IFAC-POINT TRN
C       2       ->  TWIDDLE COEFFICIENT FOR 2ND POINT OF TRANSFORM NO. G
C   UPTO IFAC  -> TWIDDLE COEFFICIENT FOR IFAC'TH POINT,
C  WHERE G IS THE NUMBER OF THE GROUP.
C
        NPT = 0
        NP = 0
        NS = 1
        J = IFAC - 1
        DO 80 I = 1, N, IFAC
          IDR(I) = NP + NS
          DO 82 II=1, J
            IDR(I+II) = NPT * II
   82     CONTINUE
          NP = NP + 1
          NPT = NPT + ITWINC
          IF (NP.LT.ISPAN) GOTO 79
          NP = 0
          NPT = 0
          NS = NS + ISKIP
   79     CONTINUE
   80   CONTINUE
        IRBASE = 0
C  START OF OUTER LOOP OVER GROUP OF ROWS
  110   CONTINUE
        IRTW = 1
C       BIAS BY 1 FOR LOOKUP, BUF(1) = SIN(0) = IMAG(W/SUB 0/)
        JRTW = 0
C  INNER LOOP OVER ROWS IN GROUP
        DO 250 NROW = 1, ISPAN
C  INITIALISE ROW BASE COORDINATES ( OR FETCH ROWS FROM MS)
          IR(1) = (IRBASE+NROW-1)*NNR
          DO 115 I=2,IFAC
            IR(I) = IR(I-1) + IRSEP
  115     CONTINUE
C  TRANSFORM ALL COLS IN ROW SET, NO TWIDDLING.
          NOTWID = .TRUE.
          ISEP = IRSEP
          ISTRT = IR(1)
          NTINC = 1
          CALL PTRANS (A,B,N,NTINC,NOTWID,ISTRT,IF1,ISEP,IRTW,NP1,
     1                 BUF,IDR,SIN120,COS72,SIN72,C2,S2)
C  AND NOW FOR ROW TRANSFORMS AND TWIDDLING.
C    NOW DO THE TRANSFORMS ALONG THE ROWS, WITH TWIDDLING.
          IRTW = 1
          NOTWID = ISPAN.EQ.1
C   NOTWID ON FINAL TRANSFORM BOTH INCREASES SPEED AND ENSURES
C   THAT THE RESULTS FTN RECIEVES ARE NORMALISED IF FFTR4C USED
          NTINC = IFAC
          ISEP = ICSEP
          DO 130 IRSSEQ = 1, IFAC
            ISTRT = IR(IRSSEQ)
            CALL PTRANS (A,B,N,NTINC,NOTWID,ISTRT,IF1,ISEP,IRTW,NP1,
     1                   BUF,IDR,SIN120,COS72,SIN72,C2,S2)
            IRTW = IRTW + JRTW
  130     CONTINUE
          JRTW = JRTW + ITWINC
  250   CONTINUE
C  ADVANCE TO NEXT ROW SET IF NOT ALL DONE
        IRBASE = IRBASE + ISKIP
        IF (IRBASE.LT.N) GOTO 110
        ISKIP = ISKIP / IFAC
        ITWINC = ITWINC * IFAC
C  END ITERATION OVER FACTORS
  300 CONTINUE
C
C  NOW UNSCRAMBLE THE TRANSFORM. SET UP TABLE IN IDR(J) OF WHERE LINE
C  (OR COL) J SHOULD BE MOVED TO. IX HOLDE THE DIGITS OF THE VARIABLE-
C  RADIX COORDINATE AND IDRT IS ITS DIGIT REVERSED FORM AT ALL TIMES.
C   INITIALISATION...
C
      IX(1) = 0
      IDRINC(1) = 1
      DO 310 I = 2, NFAC
        IX(I) = 0
        J = I-1
        IDRINC(I) = IDRINC(J) * NFACS(J)
  310 CONTINUE
      J = 0
      IDRT = 1
      I4 = (N-1)/2 +1
C
C  NOTE IDRT BIASSED BY 1 FOR USE AS SUBSCRIPT, IS 0 IN THEORY.
C   IDRT ALSO CAUSES A CYCLIC SHIFT OF N/2 IF WE WANT A CENTRE-ZERO RES.
C  LOOP GENERATES THE TABLE IN IDR
C
  315 J = J + 1
      IF (CENTRZ) GOTO 316
      IDR(J) = IDRT
      GOTO 318
  316 I2 = IDRT + I4
      IF (I2.LE.N) GOTO 317
      IDR(J) = I2 - N
      GOTO 318
  317 IDR(J) = I2
  318 CONTINUE
      M = NFAC
C  INCREMENT SMALLEST DIGIT, CORRESPONDING BIG INCREMENT TO IDRT
  320 IX(M) = IX(M) +1
      IDRT = IDRT + IDRINC(M)
C  CARRY?
      IF(IX(M).LT.NFACS(M)) GOTO 315
C  YES. RESET TO 0 AND MOVE TO NEXT DIGIT; CORRECT IDRT
      IX(M) = 0
      IDRT = IDRT - NFACS(M)*IDRINC(M)
      M = M-1
      IF(M.NE.0) GOTO 320
C  WE EXIT WHEN WE HAVE 'GONE ROUND CLOCK' ONCE.
      FNPTS = 1.0 / FLOAT(N*N)
      IF (USERNM) FNPTS=FORWRD
      IF (USERNM.AND.REVTRN) FNPTS=BAKWRD
      FNPTS2=FNPTS
      IF(REVTRN) FNPTS2=-FNPTS
      NP1 = N +1
C
C  UNSCRAMBLE THE ARRAYS.
C
      DO 800 NROW = 1, N
        M=NROW
C  HAS THE ROW BEEN RESORTED ALREADY?
        IF (IDR(M).LT.0) GOTO 801
        MBASE = (M-1)*NNR
        I = M
        IRBASE = MBASE
C  MOVE LINE I TO BUFFER
        DO 810 J=1, N
          I2 = IRBASE + J
          BUF(J)=A(I2)
          BUF(J+NP1) = B(I2)
  810   CONTINUE
C  MARK ROW I AS SORTED, UPDATE I
  815   I2 = IDR(I)
        IDR(I) = -I2
        I = I2
        IRBASE = (I-1)*NNR
C  UNSCRAMBLE BUFFER TO LINE M, EXIT IF (NEW) I .EQ.M
C  ALSO PERFORM NORMALISATION ON REVERSE TRANSFORM, AND PRE-SHIFTING
C  IF CENTRE-ZERO BY USE OF POST-GRIDDING. THE TEST WHETHER TO MULTIPLY
C  BY -1 IS THAT EITHER (I-I4) OR (IREV-I4), NOT BOTH, IS ODD.
C  THIS CAN BE COLLAPSED TO A TEST FOR (I-I4 + IREV-I4) ODD, OR
C  SIMPLY ON (I+IREV)
        DO 820 J = 1, N
          NP = IABS(IDR(J))
          IREV = NP + MBASE
          IF (REVTRN.OR.USERNM) GOTO 825
          A1 = BUF(J)
          B1 = BUF(J+NP1)
          GOTO 827
  825     A1 = BUF(J) * FNPTS
          B1 = -BUF(J+NP1)*FNPTS
  827     IF (CENTRZ.AND.MOD(NP+I, 2).NE.0) GOTO 828
          A(IREV) = A1
          B(IREV) = B1
          GOTO 819
  828     A(IREV) = -A1
          B(IREV) = -B1
  819     CONTINUE
  820   CONTINUE
        IF (M.EQ.I) GOTO 801
C  NOT END OF CYCLE. MOVE LINE I TO BUFFER AND LINE M TO LINE I
        DO 830 J = 1, N
          I2 = IRBASE + J
          BUF(J) = A(I2)
          BUF(J+NP1) = B(I2)
          I4 = MBASE + J
          A(I2) = A(I4)
          B(I2) = B(I4)
  830   CONTINUE
        GOTO 815
  801   CONTINUE
  800 CONTINUE
      RETURN
      END
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      SUBROUTINE PTRANS (A,B,N,NTINC,NOTWID,ISTRT,IF1,ISEP,IRTW,NP1,
     1                   BUF,IDR,SIN120,COS72,SIN72,C2,S2)
C
C PURPOSE: PROCEDURE FOR DOING A SET OF IFAC-POINT TRANSFORMS
C          STARTING WITH POINTA WHOSE COORDS ARE HELD IN IX()
C
      REAL A(1),B(1),BUF(1)
      INTEGER IDR(1)
      LOGICAL NOTWID
C
C-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
C Local Variables:
C
      REAL    A1(2048),A2(2048),A3(2048),A4(2048),A23(2048)
      REAL    B1(2048),B2(2048),B3(2048),B4(2048),B23(2048)
      REAL    AA(2048),BB(2048),AK(2048),BK(2048),AJ(2048),BJ(2048)
      REAL    C(2048),S(2048),C2(2048),S2(2048)
      INTEGER IX1(2048),IX2(2048),IX3(2048),IX4(2048),IX5(2048)
C
C-----------------------------------------------------------------------
C
      IF (NOTWID) THEN
         DO 100 NTR = 1, N, NTINC
            IX1(NTR) = ISTRT + NTR
 100     CONTINUE
      ELSE
         DO 150 NTR = 1, N, NTINC
 208        IX1(NTR) = ISTRT + IDR(NTR)
 150     CONTINUE
      ENDIF
      DO 180 NTR = 1, N, NTINC
         IX2(NTR) = IX1(NTR) + ISEP
         IX3(NTR) = IX2(NTR) + ISEP
         IX4(NTR) = IX3(NTR) + ISEP
         IX5(NTR) = IX4(NTR) + ISEP
 180  CONTINUE

C
      GOTO (200,300,400,500),IF1
C
C========TWO POINT TRANSFORM
C
 200  DO 2000 NTR = 1, N, NTINC
         A2(NTR) = A(IX2(NTR))
         B2(NTR) = B(IX2(NTR))
 2000 CONTINUE
C
      DO 2002 NTR = 1, N, NTINC
         A(IX2(NTR)) = A(IX1(NTR))-A2(NTR)
         A(IX1(NTR)) = A(IX1(NTR))+A2(NTR)
         B(IX2(NTR)) = B(IX1(NTR))-B2(NTR)
         B(IX1(NTR)) = B(IX1(NTR))+B2(NTR)
 2002 CONTINUE
      GOTO 6000
C
C========THREE POINT TRANSFORM. NOTE COS120=-0.5, LET COMPILER OPTIMISE
C       *0.5 IF POSSIBLE
C
 300  DO 3000 NTR = 1, N, NTINC
         A1(NTR) = A(IX1(NTR))
         A23(NTR) = A(IX2(NTR))+A(IX3(NTR))
 3000 CONTINUE
      DO 3001 NTR = 1, N, NTINC
         A(IX1(NTR)) = A1(NTR)+A23(NTR)
 3001 CONTINUE
      DO 3002 NTR = 1, N, NTINC
         A1(NTR) = -0.5*A23(NTR) +A1(NTR)
         A23(NTR) = (A(IX2(NTR))-A(IX3(NTR)))*SIN120
         B1(NTR) = B(IX1(NTR))
         B23(NTR) = B(IX2(NTR)) + B(IX3(NTR))
 3002 CONTINUE
      DO 3003 NTR = 1, N, NTINC
         B(IX1(NTR)) = B1(NTR)+B23(NTR)
 3003 CONTINUE
      DO 3004 NTR = 1, N, NTINC
         B1(NTR) = -0.5*B23(NTR) + B1(NTR)
         B23(NTR) = (B(IX2(NTR))-B(IX3(NTR)))*SIN120
 3004 CONTINUE
C
      DO 3005 NTR = 1, N, NTINC
         A(IX2(NTR)) = A1(NTR)-B23(NTR)
 3005 CONTINUE
      DO 3006 NTR = 1, N, NTINC
         A(IX3(NTR)) = A1(NTR)+B23(NTR)
 3006 CONTINUE
      DO 3007 NTR = 1, N, NTINC
         B(IX2(NTR)) = B1(NTR)+A23(NTR)
 3007 CONTINUE
      DO 3008 NTR = 1, N, NTINC
         B(IX3(NTR)) = B1(NTR)-A23(NTR)
 3008   CONTINUE
      GOTO 6000
C
C========FOUR POINT TRANSFORM; DO AS PAIR OF TWO POINT ONES WITH PI/2 TWIDDLE
C
 400  DO 4000 NTR = 1, N, NTINC
         A1(NTR) = A(IX1(NTR))+A(IX3(NTR))
         A3(NTR) = A(IX1(NTR))-A(IX3(NTR))
         A2(NTR) = A(IX2(NTR))+A(IX4(NTR))
         A4(NTR) = A(IX2(NTR))-A(IX4(NTR))
 4000 CONTINUE
C
      DO 4001 NTR = 1, N, NTINC
         B1(NTR) = B(IX1(NTR))+B(IX3(NTR))
         B3(NTR) = B(IX1(NTR))-B(IX3(NTR))
         B2(NTR) = B(IX2(NTR))+B(IX4(NTR))
         B4(NTR) = B(IX2(NTR))-B(IX4(NTR))
 4001 CONTINUE
C
      DO 4002 NTR = 1, N, NTINC
         A(IX1(NTR)) = A1(NTR)+A2(NTR)
 4002 CONTINUE
      DO 4003 NTR = 1, N, NTINC
         A(IX3(NTR)) = A1(NTR)-A2(NTR)
 4003 CONTINUE
      DO 4004 NTR = 1, N, NTINC
         B(IX1(NTR)) = B1(NTR)+B2(NTR)
 4004 CONTINUE
      DO 4005 NTR = 1, N, NTINC
         B(IX3(NTR)) = B1(NTR)-B2(NTR)
 4005 CONTINUE
C
      DO 4006 NTR = 1, N, NTINC
         A(IX2(NTR)) = A3(NTR)-B4(NTR)
 4006 CONTINUE
      DO 4007 NTR = 1, N, NTINC
         A(IX4(NTR)) = A3(NTR)+B4(NTR)
 4007 CONTINUE
      DO 4008 NTR = 1, N, NTINC
         B(IX2(NTR)) = B3(NTR)+A4(NTR)
 4008 CONTINUE
      DO 4009 NTR = 1, N, NTINC
         B(IX4(NTR)) = B3(NTR)-A4(NTR)
 4009 CONTINUE
      GOTO 6000
C
C  FIVE POINT TRANSFORM NOT YET IMPLEMENTED.
C
 500  DO 5000 NTR = 1, N, NTINC
C
         A1(NTR)=A(IX2(NTR))+A(IX5(NTR))
         A3(NTR)=A(IX2(NTR))-A(IX5(NTR))
         B1(NTR)=B(IX2(NTR))+B(IX5(NTR))
         B3(NTR)=B(IX2(NTR))-B(IX5(NTR))
 5000 CONTINUE
C
      DO 5001 NTR = 1, N, NTINC
         A2(NTR)=A(IX3(NTR))+A(IX4(NTR))
         A4(NTR)=A(IX3(NTR))-A(IX4(NTR))
         B2(NTR)=B(IX3(NTR))+B(IX4(NTR))
         B4(NTR)=B(IX3(NTR))-B(IX4(NTR))
 5001 CONTINUE
C
      DO 5002 NTR = 1, N, NTINC
         AA(NTR)=A(IX1(NTR))
         BB(NTR)=B(IX1(NTR))
         A(IX1(NTR))=AA(NTR)+A1(NTR)+A2(NTR)
         B(IX1(NTR))=BB(NTR)+B1(NTR)+B2(NTR)
 5002 CONTINUE
C
      DO 5003 NTR = 1, N, NTINC
         AK(NTR)=A1(NTR)*COS72+A2(NTR)*C2(NTR)+AA(NTR)
         BK(NTR)=B1(NTR)*COS72+B2(NTR)*C2(NTR)+BB(NTR)
         AJ(NTR)=A3(NTR)*SIN72+A4(NTR)*S2(NTR)
         BJ(NTR)=B3(NTR)*SIN72+B4(NTR)*S2(NTR)
 5003 CONTINUE
C
      DO 5004 NTR = 1, N, NTINC
         A(IX2(NTR))=AK(NTR)-BJ(NTR)
 5004 CONTINUE
      DO 5005 NTR = 1, N, NTINC
         A(IX5(NTR))=AK(NTR)+BJ(NTR)
 5005 CONTINUE
      DO 5006 NTR = 1, N, NTINC
         B(IX2(NTR))=BK(NTR)+AJ(NTR)
 5006 CONTINUE
      DO 5007 NTR = 1, N, NTINC
         B(IX5(NTR))=BK(NTR)-AJ(NTR)
 5007 CONTINUE
C
      DO 5008 NTR = 1, N, NTINC
         AK(NTR)=A1(NTR)*C2(NTR)+A2(NTR)*COS72+AA(NTR)
         BK(NTR)=B1(NTR)*C2(NTR)+B2(NTR)*COS72+BB(NTR)
         AJ(NTR)=A3(NTR)*S2(NTR)-A4(NTR)*SIN72
         BJ(NTR)=B3(NTR)*S2(NTR)-B4(NTR)*SIN72
 5008 CONTINUE
C
      DO 5009 NTR = 1, N, NTINC
         A(IX3(NTR))=AK(NTR)-BJ(NTR)
 5009 CONTINUE
      DO 5010 NTR = 1, N, NTINC
         A(IX4(NTR))=AK(NTR)+BJ(NTR)
 5010 CONTINUE
      DO 5011 NTR = 1, N, NTINC
         B(IX3(NTR))=BK(NTR)+AJ(NTR)
 5011 CONTINUE
      DO 5012 NTR = 1, N, NTINC
         B(IX4(NTR))=BK(NTR)-AJ(NTR)
 5012 CONTINUE
C
C  TWIDDLING
C
C  THIS CODE IS OPTIMAL FOR A LARGE MACHINE (LOOPS AND CONDITIONALS
C  EXPENSIVE - ESPECIALLY TRUE OF CDC 66/7600) BUT IF IX'S WERE MADE
C  INTO AN ARRAY, THE TWIDDLE CODE COULD BE GREATLY SHRUNK BY MAKING
C  IT INTO A LOOP.
C
 6000 IF (.NOT.NOTWID) THEN
         GOTO (220,330,440,550),IF1

 550     DO 5500 NTR = 1, N, NTINC
            ITW = IRTW + IDR(NTR+4)
            S(NTR) = BUF(ITW)
            C(NTR) = BUF(ITW+NP1)
 5500    CONTINUE
         DO 5501 NTR = 1, N, NTINC
            A4(NTR) = A(IX5(NTR))
            B4(NTR) = B(IX5(NTR))
 5501    CONTINUE
         DO 5502 NTR = 1, N, NTINC
            A(IX5(NTR)) = A4(NTR)*C(NTR) - B4(NTR)*S(NTR)
            B(IX5(NTR)) = A4(NTR)*S(NTR) + B4(NTR)*C(NTR)
 5502    CONTINUE
C
 440     DO 4400 NTR = 1, N, NTINC
            ITW = IRTW + IDR(NTR+3)
            S(NTR) = BUF(ITW)
            C(NTR) = BUF(ITW+NP1)
 4400    CONTINUE
         DO 4401 NTR = 1, N, NTINC
            A4(NTR) = A(IX4(NTR))
            B4(NTR) = B(IX4(NTR))
 4401    CONTINUE
         DO 4402 NTR = 1, N, NTINC
            A(IX4(NTR)) = A4(NTR)*C(NTR) - B4(NTR)*S(NTR)
            B(IX4(NTR)) = A4(NTR)*S(NTR) + B4(NTR)*C(NTR)
 4402    CONTINUE
C
 330     DO 3300 NTR = 1, N, NTINC
            ITW = IRTW + IDR(NTR+2)
            S(NTR) = BUF(ITW)
            C(NTR) = BUF(ITW+NP1)
 3300    CONTINUE
         DO 3301 NTR = 1, N, NTINC
            A4(NTR) = A(IX3(NTR))
            B4(NTR) = B(IX3(NTR))
 3301    CONTINUE
         DO 3302 NTR = 1, N, NTINC
            A(IX3(NTR)) = A4(NTR)*C(NTR) - B4(NTR)*S(NTR)
            B(IX3(NTR)) = A4(NTR)*S(NTR) + B4(NTR)*C(NTR)
 3302    CONTINUE
C
 220     DO 2200 NTR = 1, N, NTINC
            ITW = IRTW + IDR(NTR+1)
            S(NTR) = BUF(ITW)
            C(NTR) = BUF(ITW+NP1)
 2200    CONTINUE
         DO 2201 NTR = 1, N, NTINC
            A4(NTR) = A(IX2(NTR))
            B4(NTR) = B(IX2(NTR))
 2201    CONTINUE
         DO 2202 NTR = 1, N, NTINC
            A(IX2(NTR)) = A4(NTR)*C(NTR) - B4(NTR)*S(NTR)
            B(IX2(NTR)) = A4(NTR)*S(NTR) + B4(NTR)*C(NTR)
 2202    CONTINUE
         DO 2203 NTR = 1, N, NTINC
            A4(NTR) = A(IX1(NTR))
            B4(NTR) = B(IX1(NTR))
 2203    CONTINUE
         DO 2204 NTR = 1, N, NTINC
            S(NTR) = BUF(IRTW)
            C(NTR) = BUF(IRTW+NP1)
 2204    CONTINUE
         DO 2205 NTR = 1, N, NTINC
            A(IX1(NTR)) = A4(NTR)*C(NTR) - B4(NTR)*S(NTR)
            B(IX1(NTR)) = A4(NTR)*S(NTR) + B4(NTR)*C(NTR)
 2205    CONTINUE
      ENDIF
      RETURN
      END
